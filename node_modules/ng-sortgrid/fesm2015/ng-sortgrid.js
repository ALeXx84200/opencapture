import { Injectable, Inject, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Directive, ElementRef, Input, Output, HostListener, NgModule } from '@angular/core';
import { Subject, fromEvent, merge, timer } from 'rxjs';
import { withLatestFrom, filter, mapTo, takeUntil, throttleTime, takeWhile } from 'rxjs/operators';
import { DOCUMENT } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/helpers/element/ngsg-elements.helper.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgsgElementsHelper {
    /**
     * @param {?} element
     * @return {?}
     */
    static findIndex(element) {
        /** @type {?} */
        const allElements = element.parentNode.children;
        return Array.prototype.indexOf.call(allElements, element);
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/helpers/scroll/scroll-helper.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ScrollPoints() { }
if (false) {
    /** @type {?|undefined} */
    ScrollPoints.prototype.top;
    /** @type {?|undefined} */
    ScrollPoints.prototype.bottom;
}
class ScrollHelperService {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
        this.DEFAULT_SCROLLSPEED = 50;
        this.SCROLL_BUFFER = 50;
        this.window = document.defaultView;
    }
    /**
     * @param {?} event
     * @param {?=} scrollPoints
     * @param {?=} scrollSpeed
     * @return {?}
     */
    scrollIfNecessary(event, scrollPoints = {}, scrollSpeed) {
        /** @type {?} */
        const currentPosition = event.pageY - this.window.scrollY;
        if (this.isTopScrollNeeded(currentPosition, scrollPoints.top)) {
            this.window.scrollBy({ top: -scrollSpeed || -this.DEFAULT_SCROLLSPEED, behavior: 'smooth' });
            return;
        }
        if (this.isBottomScrollNeeded(currentPosition, scrollPoints.bottom)) {
            this.window.scrollBy({ top: scrollSpeed || this.DEFAULT_SCROLLSPEED, behavior: 'smooth' });
        }
    }
    /**
     * @private
     * @param {?} currentPosition
     * @param {?} scrollPointTop
     * @return {?}
     */
    isTopScrollNeeded(currentPosition, scrollPointTop) {
        return scrollPointTop ? currentPosition < scrollPointTop :
            currentPosition < this.SCROLL_BUFFER;
    }
    /**
     * @private
     * @param {?} currentPosition
     * @param {?} scrollPointBottom
     * @return {?}
     */
    isBottomScrollNeeded(currentPosition, scrollPointBottom) {
        return scrollPointBottom ? currentPosition > scrollPointBottom :
            currentPosition > this.window.innerHeight - this.SCROLL_BUFFER;
    }
}
ScrollHelperService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ScrollHelperService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
/** @nocollapse */ ScrollHelperService.ɵprov = ɵɵdefineInjectable({ factory: function ScrollHelperService_Factory() { return new ScrollHelperService(ɵɵinject(DOCUMENT)); }, token: ScrollHelperService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ScrollHelperService.prototype.window;
    /**
     * @type {?}
     * @private
     */
    ScrollHelperService.prototype.DEFAULT_SCROLLSPEED;
    /**
     * @type {?}
     * @private
     */
    ScrollHelperService.prototype.SCROLL_BUFFER;
    /**
     * @type {?}
     * @private
     */
    ScrollHelperService.prototype.document;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/helpers/class/ngsg-class.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgsgClassService {
    constructor() {
        this.SELECTED_DEFAULT_CLASS = 'ng-sg-selected';
        this.PLACEHOLDER_DEFAULT_CLASS = 'ng-sg-placeholder';
        this.DROPPED_DEFAULT_CLASS = 'ng-sg-dropped';
    }
    /**
     * @param {?} element
     * @return {?}
     */
    addPlaceHolderClass(element) {
        element.classList.add(this.PLACEHOLDER_DEFAULT_CLASS);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    removePlaceHolderClass(element) {
        element.classList.remove(this.PLACEHOLDER_DEFAULT_CLASS);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    addDroppedClass(element) {
        element.classList.add(this.DROPPED_DEFAULT_CLASS);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    removeDroppedClass(element) {
        element.classList.remove(this.DROPPED_DEFAULT_CLASS);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    addSelectedClass(element) {
        element.classList.add(this.SELECTED_DEFAULT_CLASS);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    removeSelectedClass(element) {
        element.classList.remove(this.SELECTED_DEFAULT_CLASS);
    }
}
NgsgClassService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NgsgClassService.ɵprov = ɵɵdefineInjectable({ factory: function NgsgClassService_Factory() { return new NgsgClassService(); }, token: NgsgClassService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgsgClassService.prototype.SELECTED_DEFAULT_CLASS;
    /**
     * @type {?}
     * @private
     */
    NgsgClassService.prototype.PLACEHOLDER_DEFAULT_CLASS;
    /**
     * @type {?}
     * @private
     */
    NgsgClassService.prototype.DROPPED_DEFAULT_CLASS;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/store/ngsg-store.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NgsgState() { }
if (false) {
    /** @type {?} */
    NgsgState.prototype.items;
    /** @type {?} */
    NgsgState.prototype.classes;
    /** @type {?} */
    NgsgState.prototype.selectedItems;
}
class NgsgStoreService {
    constructor() {
        this.state = new Map();
    }
    /**
     * @param {?} group
     * @param {?=} items
     * @param {?=} classes
     * @return {?}
     */
    initState(group, items = [], classes = {}) {
        this.state.set(group, { items: [...items], classes, selectedItems: [] });
    }
    /**
     * @param {?} group
     * @param {?} dragElement
     * @return {?}
     */
    addSelectedItem(group, dragElement) {
        this.state.get(group).selectedItems.push(dragElement);
    }
    /**
     * @param {?} group
     * @param {?} item
     * @return {?}
     */
    removeSelectedItem(group, item) {
        /** @type {?} */
        const updatedItems = this.state.get(group).selectedItems
            .filter((/**
         * @param {?} dragElement
         * @return {?}
         */
        (dragElement) => dragElement.node !== item));
        this.setSelectedItems(group, updatedItems);
    }
    /**
     * @param {?} group
     * @param {?} items
     * @return {?}
     */
    setItems(group, items) {
        this.state.get(group).items = [...items];
    }
    /**
     * @param {?} group
     * @return {?}
     */
    getItems(group) {
        return this.state.get(group).items;
    }
    /**
     * @param {?} group
     * @return {?}
     */
    hasItems(group) {
        return this.getItems(group).length > 0;
    }
    /**
     * @param {?} group
     * @return {?}
     */
    hasGroup(group) {
        return this.state.has(group);
    }
    /**
     * @param {?} group
     * @return {?}
     */
    getSelectedItems(group) {
        return this.state.get(group).selectedItems;
    }
    /**
     * @param {?} group
     * @param {?} selectedItems
     * @return {?}
     */
    setSelectedItems(group, selectedItems) {
        this.state.get(group).selectedItems = [...selectedItems];
    }
    /**
     * @param {?} group
     * @return {?}
     */
    getFirstSelectItem(group) {
        return this.state.get(group).selectedItems[0];
    }
    /**
     * @param {?} group
     * @return {?}
     */
    hasSelectedItems(group) {
        return this.getSelectedItems(group).length > 0;
    }
    /**
     * @param {?} group
     * @return {?}
     */
    resetSelectedItems(group) {
        this.setSelectedItems(group, []);
    }
    /**
     * @param {?} group
     * @return {?}
     */
    getClasses(group) {
        return this.state.get(group).classes;
    }
}
NgsgStoreService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NgsgStoreService.ɵprov = ɵɵdefineInjectable({ factory: function NgsgStoreService_Factory() { return new NgsgStoreService(); }, token: NgsgStoreService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgsgStoreService.prototype.state;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/mutliselect/ngsg-selection.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ChangeAction = {
    ADD: 0,
    REMOVE: 1,
};
ChangeAction[ChangeAction.ADD] = 'ADD';
ChangeAction[ChangeAction.REMOVE] = 'REMOVE';
/**
 * @record
 */
function SelectionChange() { }
if (false) {
    /** @type {?} */
    SelectionChange.prototype.key;
    /** @type {?} */
    SelectionChange.prototype.item;
    /** @type {?} */
    SelectionChange.prototype.action;
}
class NgsgSelectionService {
    /**
     * @param {?} classService
     * @param {?} ngsgStore
     */
    constructor(classService, ngsgStore) {
        this.classService = classService;
        this.ngsgStore = ngsgStore;
        this.COMMAND_KEY = 'Meta';
        this.CONTROL_KEY = 'Control';
        this.selectionChange$ = new Subject();
        /** @type {?} */
        const selectionKeyPressed$ = this.selectionKeyPressed();
        this.selectionChange$
            .pipe(withLatestFrom(selectionKeyPressed$))
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([selectionChange, selectionKeyPressed]) => {
            selectionKeyPressed
                ? this.handleSelectionChange(selectionChange)
                : this.resetSelectedItems(selectionChange.key);
        }));
    }
    /**
     * @private
     * @param {?} group
     * @return {?}
     */
    resetSelectedItems(group) {
        this.ngsgStore.getSelectedItems(group).forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => this.classService.removeSelectedClass(item.node)));
        this.ngsgStore.resetSelectedItems(group);
    }
    /**
     * @private
     * @param {?} selectionChange
     * @return {?}
     */
    handleSelectionChange(selectionChange) {
        if (selectionChange.action === ChangeAction.ADD) {
            this.classService.addSelectedClass(selectionChange.item);
            this.ngsgStore.addSelectedItem(selectionChange.key, {
                node: selectionChange.item,
                originalIndex: NgsgElementsHelper.findIndex(selectionChange.item)
            });
        }
        if (selectionChange.action === ChangeAction.REMOVE) {
            this.classService.removeSelectedClass(selectionChange.item);
            this.ngsgStore.removeSelectedItem(selectionChange.key, selectionChange.item);
        }
    }
    /**
     * @private
     * @return {?}
     */
    selectionKeyPressed() {
        /** @type {?} */
        const selectionKeyPressed = fromEvent(window, 'keydown').pipe(filter((/**
         * @param {?} keyboardEvent
         * @return {?}
         */
        (keyboardEvent) => keyboardEvent.key === this.COMMAND_KEY || keyboardEvent.key === this.CONTROL_KEY)), mapTo(true));
        /** @type {?} */
        const keyup = fromEvent(window, 'keyup').pipe(mapTo(false));
        return merge(selectionKeyPressed, keyup);
    }
    /**
     * @param {?} group
     * @param {?} dragedElement
     * @return {?}
     */
    selectElementIfNoSelection(group, dragedElement) {
        if (this.ngsgStore.hasSelectedItems(group)) {
            return;
        }
        this.ngsgStore.addSelectedItem(group, {
            node: dragedElement,
            originalIndex: NgsgElementsHelper.findIndex(dragedElement)
        });
    }
    /**
     * @param {?} key
     * @param {?} item
     * @param {?} selected
     * @return {?}
     */
    updateSelectedDragItem(key, item, selected) {
        this.selectionChange$.next({
            key,
            item,
            action: selected ? ChangeAction.ADD : ChangeAction.REMOVE
        });
    }
}
NgsgSelectionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgsgSelectionService.ctorParameters = () => [
    { type: NgsgClassService },
    { type: NgsgStoreService }
];
/** @nocollapse */ NgsgSelectionService.ɵprov = ɵɵdefineInjectable({ factory: function NgsgSelectionService_Factory() { return new NgsgSelectionService(ɵɵinject(NgsgClassService), ɵɵinject(NgsgStoreService)); }, token: NgsgSelectionService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgsgSelectionService.prototype.COMMAND_KEY;
    /**
     * @type {?}
     * @private
     */
    NgsgSelectionService.prototype.CONTROL_KEY;
    /**
     * @type {?}
     * @private
     */
    NgsgSelectionService.prototype.selectionChange$;
    /**
     * @type {?}
     * @private
     */
    NgsgSelectionService.prototype.classService;
    /**
     * @type {?}
     * @private
     */
    NgsgSelectionService.prototype.ngsgStore;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/shared/ngsg-events.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgsgEventsService {
    constructor() {
        this.dropped$ = new Subject();
    }
}
NgsgEventsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NgsgEventsService.ɵprov = ɵɵdefineInjectable({ factory: function NgsgEventsService_Factory() { return new NgsgEventsService(); }, token: NgsgEventsService, providedIn: "root" });
if (false) {
    /** @type {?} */
    NgsgEventsService.prototype.dropped$;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/sort/reflection/ngsg-reflect.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgsgReflectService {
    /**
     * @param {?} ngsgStore
     */
    constructor(ngsgStore) {
        this.ngsgStore = ngsgStore;
    }
    /**
     * @param {?} key
     * @param {?} element
     * @return {?}
     */
    reflectChanges(key, element) {
        /** @type {?} */
        const items = this.ngsgStore.getItems(key);
        /** @type {?} */
        const selectedElements = this.ngsgStore.getSelectedItems(key);
        /** @type {?} */
        const selectedElementIndices = this.getSelectedElementsIndices(selectedElements);
        /** @type {?} */
        const selectedItems = this.getSelectedItems(items, selectedElementIndices);
        /** @type {?} */
        const sortedIndices = selectedElementIndices.sort();
        /** @type {?} */
        const dropIndex = this.findDropIndex(selectedElements, element);
        while (sortedIndices.length > 0) {
            items.splice(sortedIndices.pop(), 1);
        }
        /** @type {?} */
        const result = this.getReflectedItems(items, selectedItems, dropIndex);
        this.ngsgStore.setItems(key, result);
        return result;
    }
    /**
     * @private
     * @param {?} items
     * @param {?} selectedItems
     * @param {?} dropIndex
     * @return {?}
     */
    getReflectedItems(items, selectedItems, dropIndex) {
        /** @type {?} */
        const beforeSelection = items.slice(0, dropIndex);
        /** @type {?} */
        const afterSelection = items.slice(dropIndex, items.length);
        return [...beforeSelection, ...selectedItems, ...afterSelection];
    }
    /**
     * @private
     * @param {?} items
     * @param {?} selectedElementIndexes
     * @return {?}
     */
    getSelectedItems(items, selectedElementIndexes) {
        /** @type {?} */
        const selectedItems = [];
        selectedElementIndexes.forEach((/**
         * @param {?} index
         * @return {?}
         */
        index => {
            selectedItems.push(items[index]);
        }));
        return selectedItems;
    }
    /**
     * @private
     * @param {?} selectedElements
     * @return {?}
     */
    getSelectedElementsIndices(selectedElements) {
        return selectedElements.map((/**
         * @param {?} selectedElement
         * @return {?}
         */
        (selectedElement) => selectedElement.originalIndex));
    }
    /**
     * @private
     * @param {?} selectedElements
     * @param {?} element
     * @return {?}
     */
    findDropIndex(selectedElements, element) {
        if (this.isDropInSelection(selectedElements, element)) {
            return NgsgElementsHelper.findIndex(selectedElements[0].node);
        }
        return NgsgElementsHelper.findIndex(element);
    }
    /**
     * @private
     * @param {?} collection
     * @param {?} dropElement
     * @return {?}
     */
    isDropInSelection(collection, dropElement) {
        return !!collection.find((/**
         * @param {?} dragElment
         * @return {?}
         */
        (dragElment) => dragElment.node === dropElement));
    }
}
NgsgReflectService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgsgReflectService.ctorParameters = () => [
    { type: NgsgStoreService }
];
/** @nocollapse */ NgsgReflectService.ɵprov = ɵɵdefineInjectable({ factory: function NgsgReflectService_Factory() { return new NgsgReflectService(ɵɵinject(NgsgStoreService)); }, token: NgsgReflectService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgsgReflectService.prototype.ngsgStore;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/sort/sort/ngsg-sort.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgsgSortService {
    /**
     * @param {?} classService
     * @param {?} ngsgStore
     */
    constructor(classService, ngsgStore) {
        this.classService = classService;
        this.ngsgStore = ngsgStore;
    }
    /**
     * @param {?} group
     * @return {?}
     */
    initSort(group) {
        this.dragIndex = this.ngsgStore.getFirstSelectItem(group).originalIndex;
        this.dragElements = this.ngsgStore.getSelectedItems(group);
    }
    /**
     * @param {?} dropElement
     * @return {?}
     */
    sort(dropElement) {
        /** @type {?} */
        const hoverIndex = NgsgElementsHelper.findIndex(dropElement);
        /** @type {?} */
        const el = this.getSibling(dropElement, this.dragIndex, hoverIndex);
        if (this.isDropInSelection(el)) {
            return;
        }
        this.dragElements.forEach((/**
         * @param {?} dragElement
         * @return {?}
         */
        (dragElement) => {
            /** @type {?} */
            const insertedNode = dropElement.parentNode.insertBefore(dragElement.node, el.node);
            this.classService.addPlaceHolderClass((/** @type {?} */ (insertedNode)));
        }));
        this.dragIndex = NgsgElementsHelper.findIndex(this.dragElements[0].node);
    }
    /**
     * @return {?}
     */
    endSort() {
        this.dragElements.forEach((/**
         * @param {?} dragElement
         * @return {?}
         */
        (dragElement) => {
            this.updateDropedItem(dragElement.node);
        }));
    }
    /**
     * @private
     * @param {?} dropElement
     * @param {?} dragIndex
     * @param {?} hoverIndex
     * @return {?}
     */
    getSibling(dropElement, dragIndex, hoverIndex) {
        if (dragIndex < hoverIndex) {
            return { node: dropElement.nextSibling, originalIndex: hoverIndex + 1 };
        }
        return { node: dropElement, originalIndex: hoverIndex };
    }
    /**
     * @private
     * @param {?} dropElement
     * @return {?}
     */
    isDropInSelection(dropElement) {
        return !!this.dragElements.find((/**
         * @param {?} dragElment
         * @return {?}
         */
        (dragElment) => dragElment.node === dropElement.node));
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    updateDropedItem(item) {
        this.classService.removePlaceHolderClass(item);
        this.classService.addDroppedClass(item);
        this.classService.removeSelectedClass(item);
        timer(500).subscribe((/**
         * @return {?}
         */
        () => this.classService.removeDroppedClass(item)));
    }
}
NgsgSortService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgsgSortService.ctorParameters = () => [
    { type: NgsgClassService },
    { type: NgsgStoreService }
];
/** @nocollapse */ NgsgSortService.ɵprov = ɵɵdefineInjectable({ factory: function NgsgSortService_Factory() { return new NgsgSortService(ɵɵinject(NgsgClassService), ɵɵinject(NgsgStoreService)); }, token: NgsgSortService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgsgSortService.prototype.dragIndex;
    /**
     * @type {?}
     * @private
     */
    NgsgSortService.prototype.dragElements;
    /**
     * @type {?}
     * @private
     */
    NgsgSortService.prototype.classService;
    /**
     * @type {?}
     * @private
     */
    NgsgSortService.prototype.ngsgStore;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngsg-item.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const selector = '[ngSortgridItem]';
class NgsgItemDirective {
    /**
     * @param {?} el
     * @param {?} sortService
     * @param {?} selectionService
     * @param {?} reflectService
     * @param {?} ngsgStore
     * @param {?} ngsgEventService
     * @param {?} scrollHelperService
     */
    constructor(el, sortService, selectionService, reflectService, ngsgStore, ngsgEventService, scrollHelperService) {
        this.el = el;
        this.sortService = sortService;
        this.selectionService = selectionService;
        this.reflectService = reflectService;
        this.ngsgStore = ngsgStore;
        this.ngsgEventService = ngsgEventService;
        this.scrollHelperService = scrollHelperService;
        this.ngSortGridGroup = 'defaultGroup';
        this.autoScroll = false;
        this.sorted = new EventEmitter();
        this.selected = false;
        this.destroy$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngsgEventService.dropped$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => this.selected = false));
        fromEvent(this.el.nativeElement, 'drag').pipe(throttleTime(20), takeUntil(this.destroy$), takeWhile((/**
         * @return {?}
         */
        () => this.autoScroll))).subscribe((/**
         * @return {?}
         */
        () => {
            this.scrollHelperService.scrollIfNecessary(event, {
                top: this.scrollPointTop,
                bottom: this.scrollPointBottom
            }, this.scrollSpeed);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const sortGridItemChanges = changes.ngSortGridItems;
        /** @type {?} */
        const sortGridItems = sortGridItemChanges.currentValue ? sortGridItemChanges.currentValue : [];
        if (!this.ngsgStore.hasGroup(this.ngSortGridGroup)) {
            this.ngsgStore.initState(this.ngSortGridGroup, sortGridItems);
            return;
        }
        this.ngsgStore.setItems(this.ngSortGridGroup, sortGridItems);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.el.nativeElement.draggable = true;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragStart(event) {
        if (!this.occuredOnHost(event)) {
            return;
        }
        this.selectionService.selectElementIfNoSelection(this.ngSortGridGroup, event.target);
        this.sortService.initSort(this.ngSortGridGroup);
    }
    /**
     * @return {?}
     */
    dragEnter() {
        if (!this.ngsgStore.hasSelectedItems(this.ngSortGridGroup)) {
            return;
        }
        this.sortService.sort(this.el.nativeElement);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragOver(event) {
        if (event.preventDefault) {
            // Necessary. Allows us to drop.
            event.preventDefault();
        }
        return false;
    }
    /**
     * @return {?}
     */
    drop() {
        if (!this.ngsgStore.hasSelectedItems(this.ngSortGridGroup)) {
            return;
        }
        if (!this.ngsgStore.hasItems(this.ngSortGridGroup)) {
            console.warn(`Ng-sortgrid: No items provided - please use [sortGridItems] to pass in an array of items -
      otherwhise the ordered items can not be emitted in the (sorted) event`);
            return;
        }
        /** @type {?} */
        const previousOrder = [...this.ngsgStore.getItems(this.ngSortGridGroup)];
        this.sortService.endSort();
        /** @type {?} */
        const currentOrder = this.reflectService.reflectChanges(this.ngSortGridGroup, this.el.nativeElement);
        this.sorted.next({ previousOrder, currentOrder });
        this.ngsgStore.resetSelectedItems(this.ngSortGridGroup);
        this.ngsgEventService.dropped$.next();
    }
    /**
     * @return {?}
     */
    clicked() {
        this.selected = !this.isItemCurrentlySelected();
        this.selectionService.updateSelectedDragItem(this.ngSortGridGroup, this.el.nativeElement, this.selected);
    }
    /**
     * @private
     * @return {?}
     */
    isItemCurrentlySelected() {
        /** @type {?} */
        const index = NgsgElementsHelper.findIndex(this.el.nativeElement);
        return !!this.ngsgStore.getSelectedItems(this.ngSortGridGroup)
            .find((/**
         * @param {?} element
         * @return {?}
         */
        element => element.originalIndex === index));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    occuredOnHost(event) {
        return event.target.matches(selector);
    }
}
NgsgItemDirective.decorators = [
    { type: Directive, args: [{ selector },] }
];
/** @nocollapse */
NgsgItemDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgsgSortService },
    { type: NgsgSelectionService },
    { type: NgsgReflectService },
    { type: NgsgStoreService },
    { type: NgsgEventsService },
    { type: ScrollHelperService }
];
NgsgItemDirective.propDecorators = {
    ngSortGridGroup: [{ type: Input }],
    ngSortGridItems: [{ type: Input }],
    scrollPointTop: [{ type: Input }],
    scrollPointBottom: [{ type: Input }],
    scrollSpeed: [{ type: Input }],
    autoScroll: [{ type: Input }],
    sorted: [{ type: Output }],
    dragStart: [{ type: HostListener, args: ['dragstart', ['$event'],] }],
    dragEnter: [{ type: HostListener, args: ['dragenter',] }],
    dragOver: [{ type: HostListener, args: ['dragover', ['$event'],] }],
    drop: [{ type: HostListener, args: ['dragend',] }],
    clicked: [{ type: HostListener, args: ['click',] }]
};
if (false) {
    /** @type {?} */
    NgsgItemDirective.prototype.ngSortGridGroup;
    /** @type {?} */
    NgsgItemDirective.prototype.ngSortGridItems;
    /** @type {?} */
    NgsgItemDirective.prototype.scrollPointTop;
    /** @type {?} */
    NgsgItemDirective.prototype.scrollPointBottom;
    /** @type {?} */
    NgsgItemDirective.prototype.scrollSpeed;
    /** @type {?} */
    NgsgItemDirective.prototype.autoScroll;
    /** @type {?} */
    NgsgItemDirective.prototype.sorted;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.selected;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.destroy$;
    /** @type {?} */
    NgsgItemDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.sortService;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.selectionService;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.reflectService;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.ngsgStore;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.ngsgEventService;
    /**
     * @type {?}
     * @private
     */
    NgsgItemDirective.prototype.scrollHelperService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngsg.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgsgModule {
}
NgsgModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgsgItemDirective],
                exports: [NgsgItemDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/shared/ngsg-order-change.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function NgsgOrderChange() { }
if (false) {
    /** @type {?} */
    NgsgOrderChange.prototype.previousOrder;
    /** @type {?} */
    NgsgOrderChange.prototype.currentOrder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ng-sortgrid.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgsgItemDirective, NgsgModule, NgsgSortService as ɵa, NgsgClassService as ɵb, NgsgStoreService as ɵc, NgsgSelectionService as ɵd, NgsgReflectService as ɵe, NgsgEventsService as ɵf, ScrollHelperService as ɵg };
//# sourceMappingURL=ng-sortgrid.js.map
