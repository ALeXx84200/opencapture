import { Pipe, EventEmitter, Component, forwardRef, HostBinding, Input, Output, ViewChild, HostListener, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { CommonModule } from '@angular/common';
import { MatChipsModule } from '@angular/material/chips';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/material/chips';
import * as ɵngcc3 from '@angular/material/tooltip';
import * as ɵngcc4 from '@angular/material/icon';

const _c0 = ["fileInputEl"];
function NgxFileDragDropComponent_mat_chip_list_0_mat_chip_1_mat_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon", 9);
    ɵngcc0.ɵɵtext(1, "cancel");
    ɵngcc0.ɵɵelementEnd();
} }
function NgxFileDragDropComponent_mat_chip_list_0_mat_chip_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-chip", 6);
    ɵngcc0.ɵɵlistener("removed", function NgxFileDragDropComponent_mat_chip_list_0_mat_chip_1_Template_mat_chip_removed_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const file_r5 = ctx.$implicit; const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.removeFile(file_r5); });
    ɵngcc0.ɵɵpipe(1, "byte");
    ɵngcc0.ɵɵelementStart(2, "span", 7);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NgxFileDragDropComponent_mat_chip_list_0_mat_chip_1_mat_icon_4_Template, 2, 0, "mat-icon", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r5 = ctx.$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵpropertyInterpolate("matTooltip", ɵngcc0.ɵɵpipeBind1(1, 6, file_r5.size));
    ɵngcc0.ɵɵproperty("matTooltipDisabled", ctx_r4.displayFileSize)("disabled", ctx_r4.disabled)("removable", !ctx_r4.disabled);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.getFileName(file_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.disabled);
} }
function NgxFileDragDropComponent_mat_chip_list_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-chip-list", 4);
    ɵngcc0.ɵɵtemplate(1, NgxFileDragDropComponent_mat_chip_list_0_mat_chip_1_Template, 5, 8, "mat-chip", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.files);
} }
function NgxFileDragDropComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.emptyPlaceholder);
} }
class BytePipe {
    constructor() {
        this.unit = 'Bytes';
    }
    transform(value, decimals) {
        value = value.toString();
        if (parseInt(value, 10) >= 0) {
            value = this.formatBytes(+value, +decimals);
        }
        return value;
    }
    // https://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript
    formatBytes(bytes, decimals = 2) {
        if (bytes === 0) {
            return '0 Bytes';
        }
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
}
BytePipe.ɵfac = function BytePipe_Factory(t) { return new (t || BytePipe)(); };
BytePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "byte", type: BytePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BytePipe, [{
        type: Pipe,
        args: [{
                name: 'byte'
            }]
    }], function () { return []; }, null); })();

class NgxFileDragDropComponent {
    constructor() {
        this.valueChanged = new EventEmitter();
        // does no validation, just sets the hidden file input
        this.accept = '*';
        this._disabled = false;
        this._multiple = false;
        this.emptyPlaceholder = `Drop file${this.multiple ? 's' : ''} or click to select`;
        this._displayFileSize = false;
        this._activeBorderColor = 'purple';
        this._files = [];
        this._isDragOver = false;
        // https://angular.io/api/forms/ControlValueAccessor
        this._onChange = (val) => { };
        this._onTouched = () => { };
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(val) {
        this._disabled = coerceBooleanProperty(val);
    }
    set multiple(value) {
        this._multiple = coerceBooleanProperty(value);
    }
    get multiple() {
        return this._multiple;
    }
    set displayFileSize(value) {
        this._displayFileSize = coerceBooleanProperty(value);
    }
    get displayFileSize() {
        return this._displayFileSize;
    }
    set borderColor(color) {
        this._activeBorderColor = color;
    }
    get borderColor() {
        return this.isDragover ? this._activeBorderColor : '#ccc';
    }
    get files() {
        return this._files;
    }
    get isEmpty() {
        var _a;
        return !((_a = this.files) === null || _a === void 0 ? void 0 : _a.length);
    }
    // @HostBinding('class.drag-over')
    get isDragover() {
        return this._isDragOver;
    }
    set isDragover(value) {
        if (!this.disabled) {
            this._isDragOver = value;
        }
    }
    writeValue(files) {
        const fileArray = this.convertToArray(files);
        if (fileArray.length < 2 || this.multiple) {
            this._files = fileArray;
            this.emitChanges(this._files);
        }
        else {
            throw Error('Multiple files not allowed');
        }
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    emitChanges(files) {
        this.valueChanged.emit(files);
        this._onChange(files);
    }
    addFiles(files) {
        // this._onTouched();
        const fileArray = this.convertToArray(files);
        if (this.multiple) {
            // this.errorOnEqualFilenames(fileArray);
            const merged = this.files.concat(fileArray);
            this.writeValue(merged);
        }
        else {
            this.writeValue(fileArray);
        }
    }
    removeFile(file) {
        const fileIndex = this.files.indexOf(file);
        if (fileIndex >= 0) {
            const currentFiles = this.files.slice();
            currentFiles.splice(fileIndex, 1);
            this.writeValue(currentFiles);
        }
    }
    clear() {
        this.writeValue([]);
    }
    change(event) {
        event.stopPropagation();
        this._onTouched();
        const fileList = event.target.files;
        if (fileList === null || fileList === void 0 ? void 0 : fileList.length) {
            this.addFiles(fileList);
        }
        // clear it so change is triggered if same file is selected again
        event.target.value = '';
    }
    activate(e) {
        e.preventDefault();
        this.isDragover = true;
    }
    deactivate(e) {
        e.preventDefault();
        this.isDragover = false;
    }
    handleDrop(e) {
        this.deactivate(e);
        if (!this.disabled) {
            const fileList = e.dataTransfer.files;
            this.removeDirectories(fileList).then((files) => {
                if (files === null || files === void 0 ? void 0 : files.length) {
                    this.addFiles(files);
                }
                this._onTouched();
            });
        }
    }
    open() {
        var _a;
        if (!this.disabled) {
            (_a = this.fileInputEl) === null || _a === void 0 ? void 0 : _a.nativeElement.click();
        }
    }
    // @HostListener('focusout')
    // blur() {
    //   console.log('blurred')
    //   this._onTouched();
    // }
    // private errorOnEqualFilenames(files: File[]) {
    //   if (this.files.some(file => files.some(file2 => file.name === file2.name))) {
    //     throw Error('one of the provided filenames already exists')
    //   }
    //   for (let i = 0; i < files.length; i++) {
    //     for (let j = i + 1; j < files.length; j++) {
    //       if (files[i].name === files[j].name) {
    //         throw Error(`can't add multiple files with same name`)
    //       }
    //     }
    //   }
    // }
    removeDirectories(files) {
        return new Promise((resolve, reject) => {
            const fileArray = this.convertToArray(files);
            const dirnames = [];
            const readerList = [];
            for (let i = 0; i < fileArray.length; i++) {
                const reader = new FileReader();
                reader.onerror = () => {
                    dirnames.push(fileArray[i].name);
                };
                reader.onloadend = () => addToReaderList(i);
                reader.readAsArrayBuffer(fileArray[i]);
            }
            function addToReaderList(val) {
                readerList.push(val);
                if (readerList.length === fileArray.length) {
                    resolve(fileArray.filter((file) => !dirnames.includes(file.name)));
                }
            }
        });
    }
    convertToArray(files) {
        if (files) {
            if (files instanceof File) {
                return [files];
            }
            else if (Array.isArray(files)) {
                return files;
            }
            else {
                return Array.prototype.slice.call(files);
            }
        }
        return [];
    }
    getFileName(file) {
        if (!this._displayFileSize) {
            return file.name;
        }
        const size = new BytePipe().transform(file.size);
        return `${file.name} (${size})`;
    }
}
NgxFileDragDropComponent.ɵfac = function NgxFileDragDropComponent_Factory(t) { return new (t || NgxFileDragDropComponent)(); };
NgxFileDragDropComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxFileDragDropComponent, selectors: [["ngx-file-drag-drop"]], viewQuery: function NgxFileDragDropComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fileInputEl = _t.first);
    } }, hostVars: 6, hostBindings: function NgxFileDragDropComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("change", function NgxFileDragDropComponent_change_HostBindingHandler($event) { return ctx.change($event); })("dragenter", function NgxFileDragDropComponent_dragenter_HostBindingHandler($event) { return ctx.activate($event); })("dragover", function NgxFileDragDropComponent_dragover_HostBindingHandler($event) { return ctx.activate($event); })("dragleave", function NgxFileDragDropComponent_dragleave_HostBindingHandler($event) { return ctx.deactivate($event); })("drop", function NgxFileDragDropComponent_drop_HostBindingHandler($event) { return ctx.handleDrop($event); })("click", function NgxFileDragDropComponent_click_HostBindingHandler() { return ctx.open(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("border-color", ctx.borderColor);
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled)("empty-input", ctx.isEmpty);
    } }, inputs: { accept: "accept", emptyPlaceholder: "emptyPlaceholder", disabled: "disabled", multiple: "multiple", displayFileSize: "displayFileSize", borderColor: ["activeBorderColor", "borderColor"] }, outputs: { valueChanged: "valueChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NgxFileDragDropComponent),
                multi: true
            }])], decls: 5, vars: 4, consts: [["selectable", "false", 4, "ngIf"], ["class", "placeholder", 4, "ngIf"], ["type", "file", 1, "hidden"], ["fileInputEl", "", "fileInput", ""], ["selectable", "false"], ["matTooltipPosition", "below", "selected", "", "color", "accent", "disableRipple", "true", 3, "matTooltip", "matTooltipDisabled", "disabled", "removable", "removed", 4, "ngFor", "ngForOf"], ["matTooltipPosition", "below", "selected", "", "color", "accent", "disableRipple", "true", 3, "matTooltip", "matTooltipDisabled", "disabled", "removable", "removed"], [1, "filename"], ["matChipRemove", "", 4, "ngIf"], ["matChipRemove", ""], [1, "placeholder"]], template: function NgxFileDragDropComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxFileDragDropComponent_mat_chip_list_0_Template, 2, 1, "mat-chip-list", 0);
        ɵngcc0.ɵɵtemplate(1, NgxFileDragDropComponent_span_1_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵelement(2, "input", 2, 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.files.length);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.files.length);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("multiple", ctx.multiple ? "" : null)("accept", ctx.accept);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.MatChipList, ɵngcc1.NgForOf, ɵngcc2.MatChip, ɵngcc3.MatTooltip, ɵngcc4.MatIcon, ɵngcc2.MatChipRemove], pipes: [BytePipe], styles: ["input[_ngcontent-%COMP%]{height:0;opacity:0;overflow:hidden;position:absolute;width:0;z-index:-1}[_nghost-%COMP%]{border:2px dashed;border-radius:20px;cursor:pointer;display:block;margin:10px auto;max-width:500px;min-height:50px;padding:20px}.disabled[_nghost-%COMP%]{cursor:unset;opacity:.5}.placeholder[_ngcontent-%COMP%]{color:grey;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}mat-chip[_ngcontent-%COMP%]{max-width:100%}.filename[_ngcontent-%COMP%]{max-width:calc(100% - 1em);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.empty-input[_nghost-%COMP%]{align-items:center;display:flex;justify-content:center}.mat-chip.mat-standard-chip.mat-focus-indicator[_ngcontent-%COMP%]{box-shadow:none}.mat-chip.mat-standard-chip[_ngcontent-%COMP%]:after{background:unset}"] });
NgxFileDragDropComponent.ctorParameters = () => [];
NgxFileDragDropComponent.propDecorators = {
    disabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    multiple: [{ type: Input }],
    displayFileSize: [{ type: Input }],
    borderColor: [{ type: Input, args: ['activeBorderColor',] }, { type: HostBinding, args: ['style.border-color',] }],
    isEmpty: [{ type: HostBinding, args: ['class.empty-input',] }],
    valueChanged: [{ type: Output }],
    fileInputEl: [{ type: ViewChild, args: ['fileInputEl',] }],
    accept: [{ type: Input }],
    emptyPlaceholder: [{ type: Input }],
    change: [{ type: HostListener, args: ['change', ['$event'],] }],
    activate: [{ type: HostListener, args: ['dragenter', ['$event'],] }, { type: HostListener, args: ['dragover', ['$event'],] }],
    deactivate: [{ type: HostListener, args: ['dragleave', ['$event'],] }],
    handleDrop: [{ type: HostListener, args: ['drop', ['$event'],] }],
    open: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxFileDragDropComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-file-drag-drop',
                template: "<mat-chip-list *ngIf=\"files.length\" selectable=\"false\">\r\n    <mat-chip matTooltip={{file.size|byte}} matTooltipPosition=\"below\" [matTooltipDisabled]=\"displayFileSize\" selected\r\n        *ngFor=\"let file of files\" [disabled]=\"disabled\" color=\"accent\" disableRipple=\"true\" [removable]=\"!disabled\"\r\n        (removed)=\"removeFile(file)\">\r\n        <span class=\"filename\">{{getFileName(file)}}</span>\r\n        <mat-icon *ngIf=\"!disabled\" matChipRemove>cancel</mat-icon>\r\n    </mat-chip>\r\n</mat-chip-list>\r\n<span class=\"placeholder\" *ngIf=\"!files.length\">{{emptyPlaceholder}}</span>\r\n<input #fileInputEl class=\"hidden\" #fileInput type=\"file\" [attr.multiple]=\"multiple? '' : null\" [attr.accept]=\"accept\">",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NgxFileDragDropComponent),
                        multi: true
                    }],
                styles: ["input{height:0;opacity:0;overflow:hidden;position:absolute;width:0;z-index:-1}:host{border:2px dashed;border-radius:20px;cursor:pointer;display:block;margin:10px auto;max-width:500px;min-height:50px;padding:20px}:host.disabled{cursor:unset;opacity:.5}.placeholder{color:grey;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}mat-chip{max-width:100%}.filename{max-width:calc(100% - 1em);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host.empty-input{align-items:center;display:flex;justify-content:center}.mat-chip.mat-standard-chip.mat-focus-indicator{box-shadow:none}.mat-chip.mat-standard-chip:after{background:unset}"]
            }]
    }], function () { return []; }, { valueChanged: [{
            type: Output
        }], accept: [{
            type: Input
        }], emptyPlaceholder: [{
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }, {
            type: Input
        }], multiple: [{
            type: Input
        }], displayFileSize: [{
            type: Input
        }], borderColor: [{
            type: Input,
            args: ['activeBorderColor']
        }, {
            type: HostBinding,
            args: ['style.border-color']
        }], isEmpty: [{
            type: HostBinding,
            args: ['class.empty-input']
        }], change: [{
            type: HostListener,
            args: ['change', ['$event']]
        }], activate: [{
            type: HostListener,
            args: ['dragenter', ['$event']]
        }, {
            type: HostListener,
            args: ['dragover', ['$event']]
        }], deactivate: [{
            type: HostListener,
            args: ['dragleave', ['$event']]
        }], handleDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }], open: [{
            type: HostListener,
            args: ['click']
        }], fileInputEl: [{
            type: ViewChild,
            args: ['fileInputEl']
        }] }); })();

class NgxFileDragDropModule {
}
NgxFileDragDropModule.ɵfac = function NgxFileDragDropModule_Factory(t) { return new (t || NgxFileDragDropModule)(); };
NgxFileDragDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxFileDragDropModule });
NgxFileDragDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatChipsModule,
            MatIconModule,
            MatTooltipModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxFileDragDropModule, { declarations: function () { return [NgxFileDragDropComponent, BytePipe]; }, imports: function () { return [CommonModule,
        MatChipsModule,
        MatIconModule,
        MatTooltipModule]; }, exports: function () { return [NgxFileDragDropComponent, BytePipe]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxFileDragDropModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxFileDragDropComponent, BytePipe],
                imports: [
                    CommonModule,
                    MatChipsModule,
                    MatIconModule,
                    MatTooltipModule
                ],
                exports: [NgxFileDragDropComponent, BytePipe]
            }]
    }], null, null); })();

// @dynamic
class FileValidators {
    static fileExtension(ext) {
        return (control) => {
            const validExtensions = ext.map(e => e.trim().toLowerCase());
            const fileArray = control.value;
            const invalidFiles = fileArray.map(file => file.name).filter(fname => {
                const extension = fname.slice((fname.lastIndexOf('.') - 1 >>> 0) + 2).toLowerCase();
                return !validExtensions.includes(extension);
            }).map(name => ({ name, ext: name.slice((name.lastIndexOf('.') - 1 >>> 0) + 2) }));
            return !invalidFiles.length
                ? null
                : {
                    fileExtension: {
                        requiredExtension: ext.toString(),
                        actualExtensions: invalidFiles
                    }
                };
        };
    }
    static uniqueFileNames(control) {
        const fileNameArray = control.value.map(file => file.name);
        const duplicates = fileNameArray.reduce((acc, curr) => {
            acc[curr] = acc[curr] ? acc[curr] + 1 : 1;
            return acc;
        }, {});
        const duplicatesArray = Object.entries(duplicates)
            .filter(arr => arr[1] > 1)
            .map(arr => ({ name: arr[0], count: arr[1] }));
        return !duplicatesArray.length
            ? null
            : {
                uniqueFileNames: { duplicatedFileNames: duplicatesArray }
            };
    }
    static fileType(types) {
        return (control) => {
            let regExp;
            if (Array.isArray(types)) {
                const joinedTypes = types.join('$|^');
                regExp = new RegExp(`$${joinedTypes}^`, 'i');
            }
            else {
                regExp = types;
            }
            const fileArray = control.value;
            const invalidFiles = fileArray.filter(file => !regExp.test(file.type)).map(file => ({ name: file.name, type: file.type }));
            return !invalidFiles.length
                ? null
                : {
                    fileType: {
                        requiredType: types.toString(),
                        actualTypes: invalidFiles
                    }
                };
        };
    }
    static maxFileCount(count) {
        return (control) => {
            const fileCount = (control === null || control === void 0 ? void 0 : control.value) ? control.value.length : 0;
            const result = count >= fileCount;
            return result
                ? null
                : {
                    maxFileCount: {
                        maxCount: count,
                        actualCount: fileCount
                    }
                };
        };
    }
    static maxFileSize(bytes) {
        return (control) => {
            const fileArray = control.value;
            const invalidFiles = fileArray.filter(file => file.size > bytes).map(file => ({ name: file.name, size: file.size }));
            return !invalidFiles.length
                ? null
                : {
                    maxFileSize: {
                        maxSize: bytes,
                        actualSizes: invalidFiles
                    }
                };
        };
    }
    static maxTotalSize(bytes) {
        return (control) => {
            const size = (control === null || control === void 0 ? void 0 : control.value) ? control.value.map(file => file.size).reduce((acc, i) => acc + i, 0) : 0;
            const result = bytes >= size;
            return result
                ? null
                : {
                    maxTotalSize: {
                        maxSize: bytes,
                        actualSize: size
                    }
                };
        };
    }
    static required(control) {
        var _a;
        const count = (_a = control === null || control === void 0 ? void 0 : control.value) === null || _a === void 0 ? void 0 : _a.length;
        return count
            ? null
            : {
                required: true
            };
    }
}

/*
 * Public API Surface of ngx-file-drag-drop
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BytePipe, FileValidators, NgxFileDragDropComponent, NgxFileDragDropModule };

//# sourceMappingURL=ngx-file-drag-drop.js.map